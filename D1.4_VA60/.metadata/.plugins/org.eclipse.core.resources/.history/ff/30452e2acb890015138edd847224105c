/******************************************************************************
 * Copyright 2013-2014 Espressif Systems (Wuxi)
 *
 * FileName: user_main.c
 *
 * Description: entry file of user application
 *
 * Modification history:
 *     2014/1/1, v1.0 create this file.
*******************************************************************************/
#include "ets_sys.h"
#include "osapi.h"
#include "uart.h"
#include "mem.h"
#include "GPIO.h"

#include "user_interface.h"
#include "smartconfig.h"
#include "espconn.h"

#include "html_file.h"
#include "SHT20.h"
#include "i2c_master.h"
#include "lewei50.h"
#include "TCPclient.h"


#define INITFLAG_MEM_NUM 20
#define INITFLAG_MEM_ADDR 120
#define NOT_POWER_ON 0x7e7e55aa

typedef struct{
	uint32 init_flg;
	uint16 cnt;
	uint16 wifi_config;
	uint16 data[INITFLAG_MEM_NUM];
}INITFLAG_MEM;



LOCAL struct espconn esp_conn;
LOCAL esp_tcp esptcp;
LOCAL os_timer_t check_ip_timer;



typedef enum {
	work_state_noip           = 0,	//did not got ip
	work_state_set_ser,				//set server
	work_state_got_set,				//got set data
	work_state_conn_ap,				//connected to another AP
	work_state_conn_ser,			//connected to server
	work_state_send_ok				//send OK
} _work_state;
_work_state work_state;

uint32 interval_timer_cnt;
uint32 content_length;
uint32 ssid_length;
char apssid[10][32];
char myssid[32];
char mypsw[64];
char mymacaddr[]="A1:B2:C3:D4:E5:F6";
char conn_ssid[32];
char conn_psw[64];
char ssidloop=0;
char ssid_send[1024];//the format to send include SSIDs

char config_state=0;


#define SERVER_LOCAL_PORT   80//1112

os_timer_t rtc_test_t;
os_timer_t test_timer;
os_timer_t search_timer;//search ap timeout timer
os_timer_t led_flash_timer;


LOCAL void ICACHE_FLASH_ATTR 	esp_VA_load_param			(void);
LOCAL void ICACHE_FLASH_ATTR 	esp_VA_save_param			(void);
void 							test_timer_cb				();
void 							search_timer_cb				();
void 							led_flash_timer_cb			();

LOCAL void ICACHE_FLASH_ATTR 	tcp_server_sent_cb			(void *arg);
LOCAL void ICACHE_FLASH_ATTR 	tcp_server_recv_cb			(void *arg, char *pusrdata, unsigned short length);
LOCAL void ICACHE_FLASH_ATTR 	tcp_server_discon_cb		(void *arg);
LOCAL void ICACHE_FLASH_ATTR 	tcp_server_recon_cb			(void *arg, sint8 err);
LOCAL void 						tcp_server_mutli_sent		(void);
LOCAL void ICACHE_FLASH_ATTR 	tcp_server_listen			(void *arg);
void ICACHE_FLASH_ATTR 			user_tcpserver_init			(uint32 port);
void ICACHE_FLASH_ATTR 			user_esp_platform_check_ip	(void);
void ICACHE_FLASH_ATTR 			user_set_station_config		(void);
void ICACHE_FLASH_ATTR 			scan_done					(void *arg, STATUS status);
void ICACHE_FLASH_ATTR 			user_scan					(void);
void ICACHE_FLASH_ATTR 			smartconfig_done			(sc_status status, void *pdata);
void ICACHE_FLASH_ATTR 			user_set_softap_config		(void);

void ICACHE_FLASH_ATTR 			key_init					(void);
void ICACHE_FLASH_ATTR 			pin_init					(uint32 gpio_name,uint8 gpio_id,uint8 gpio_func);

void ICACHE_FLASH_ATTR			RTC_memory_read				(void);
void 							user_rf_pre_init			(void);
void 							user_init					(void);




void ICACHE_FLASH_ATTR user_esp_platform_check_ip(void);
void ICACHE_FLASH_ATTR user_tcpserver_init(uint32 port);


#define esp_VA_user_param_addr 0x3c
struct VA_saved_param	VA_param;

LOCAL void ICACHE_FLASH_ATTR
esp_VA_load_param(void)
{
	char ssid_temp[32];
	spi_flash_read(esp_VA_user_param_addr * SPI_FLASH_SEC_SIZE,(uint32 *)&VA_param,sizeof( VA_param ));
	os_printf("VA_param.init_flag:%x \r\n",VA_param.init_flag);
	os_printf("VA_param.param_interval:%x \r\n",VA_param.param_interval);
	os_printf("VA_param.param_ap_ssid:%s \r\n",VA_param.param_ap_ssid);
	os_printf("VA_param.param_ap_psw:%s \r\n",VA_param.param_ap_psw);
	os_printf("VA_param.param_my_ssid:%s \r\n",VA_param.param_my_ssid);
	os_printf("VA_param.param_my_psw:%s \r\n",VA_param.param_my_psw);
	os_printf("VA_param.param_SN:%s \r\n",VA_param.param_SN);


	if(VA_param.init_flag!=INIT_MAGIC){

		wifi_get_macaddr(STATION_IF,mymacaddr);
		//	define the myssid by last three mac.
		os_sprintf(ssid_temp,"V&A_%02x%02x%02x wifi_HT",mymacaddr[3], mymacaddr[4], mymacaddr[5]);

		spi_flash_erase_sector(esp_VA_user_param_addr);
		VA_param.init_flag=INIT_MAGIC;
		VA_param.param_interval=0x33;//default 10min
		strcpy(VA_param.param_ap_ssid,"RD");
		strcpy(VA_param.param_ap_psw,"322325961");
		strcpy(VA_param.param_my_ssid,ssid_temp);
		strcpy(VA_param.param_my_psw,"69523223");
		strcpy(VA_param.param_SN,"00B5A3B051");//格式00xxxxxxxx		程序测试样机
		//strcpy(VA_param.param_SN,"0063E45019");//格式00xxxxxxxx  电源测试样机
		//VA_param.param_ap_ssid="RD";
		//VA_param.param_ap_psw="32232596";
		spi_flash_write(esp_VA_user_param_addr * SPI_FLASH_SEC_SIZE,(uint32 *)&VA_param,sizeof( VA_param));

		os_printf("saved and read again!!! \r\n");
		spi_flash_read(esp_VA_user_param_addr * SPI_FLASH_SEC_SIZE,(uint32 *)&VA_param,sizeof( VA_param));
			os_printf("VA_param.init_flag:%x \r\n",VA_param.init_flag);
			os_printf("VA_param.param_interval:%x \r\n",VA_param.param_interval);
			os_printf("VA_param.param_ap_ssid:%s \r\n",VA_param.param_ap_ssid);
			os_printf("VA_param.param_ap_psw:%s \r\n",VA_param.param_ap_psw);
			os_printf("VA_param.param_my_ssid:%s \r\n",VA_param.param_my_ssid);
			os_printf("VA_param.param_my_psw:%s \r\n",VA_param.param_my_psw);
			os_printf("VA_param.param_SN:%s \r\n",VA_param.param_SN);
			//user_set_station_config();
	}
	else{
		//user_set_station_config();
	}
	switch(VA_param.param_interval){
	case 0x31: 	interval_timer_cnt=(1*60-6)*1000000;break;//1min
	case 0x32: 	interval_timer_cnt=(5*60-6)*1000000;break;//5min
	case 0x33: 	interval_timer_cnt=(10*60-6)*1000000;break;//10min
	case 0x34: 	interval_timer_cnt=(30*60-6)*1000000;break;//30min
	case 0x35: 	interval_timer_cnt=(60*60-6)*100000;break;//60min  over flow
	default:	interval_timer_cnt=(5*60-6)*1000000;break;
	}
	 os_printf("get interval_timer_cnt:%d!!! \r\n",interval_timer_cnt);
}

LOCAL void ICACHE_FLASH_ATTR
esp_VA_save_param(void)
{
	spi_flash_erase_sector(esp_VA_user_param_addr);
	spi_flash_write(esp_VA_user_param_addr * SPI_FLASH_SEC_SIZE,(uint32 *)&VA_param,sizeof( VA_param));

}

void test_timer_cb(void)//test the deep sleep
{
	 //os_printf("\r\nready to sleep.\r\n");
	 //system_deep_sleep_set_option(2);//Don't make RF calibration after the waking-up from deep-sleep with a lower power consumption.
	 //system_deep_sleep(3100000);//uint32 time_in_us   sleep  3S
	uint16 gpio_status;

	gpio_status = GPIO_REG_READ(GPIO_IN_ADDRESS);

	os_printf("gpio_status:%04x! \r\n",gpio_status);


}


/******************************************************************************
 * FunctionName : search_timer_cb
 * Description  : timer search_timer callback.if search ap timeout at the first start;
 * Parameters   : none
 * Returns      : none
*******************************************************************************/
void search_timer_cb()
{
	os_timer_disarm(&search_timer);
	user_tcpserver_init(SERVER_LOCAL_PORT);

	os_timer_arm(&led_flash_timer,1000,1);

	os_printf("work_state:%d !!! \r\n",work_state);
}

void led_flash_timer_cb()
{
	static uint8 cnt10;

	cnt10=cnt10^1;

	if(cnt10==0)
	{
		gpio_output_set( 0, BIT5, BIT5, 0);//GPIO5 --0
	}
	else
	{
		gpio_output_set( BIT5, 0, BIT5, 0);//GPIO5 --1
	}
}

/******************************************************************************
 * FunctionName : tcp_server_sent_cb
 * Description  : data sent callback.
 * Parameters   : arg -- Additional argument to pass to the callback function
 * Returns      : none
*******************************************************************************/
LOCAL void ICACHE_FLASH_ATTR
tcp_server_sent_cb(void *arg)
{
   //data sent successfully
   // os_printf("tcp sent cb \r\n");
}

/******************************************************************************
 * FunctionName : tcp_server_recv_cb
 * Description  : receive callback.
 * Parameters   : arg -- Additional argument to pass to the callback function
 * Returns      : none
*******************************************************************************/
LOCAL void ICACHE_FLASH_ATTR
tcp_server_recv_cb(void *arg, char *pusrdata, unsigned short length)
{
	char cStr[200];
	char SendStr[4096];
	char *pBuf,*pBuf_psw,*pBuf_myssid,*pBuf_mypsw,*pStr,i=0,templen,temp_setssid[100],temp_setpsw[100];
	char *value_temp[65];
	char GB2312_test[100];
	char *testbuf;

	struct station_config stationConf;

	os_printf("tcp rece cb: \r\n",pusrdata);
/*********************************************/
	content_length=os_strlen(before_ssid_html)+os_strlen(before_end_html)+ssid_length;
	os_sprintf(cStr,"%d",content_length);
	    res200_html[79]=*cStr;
	    res200_html[80]=*(cStr+1);
	    res200_html[81]=*(cStr+2);
	    res200_html[82]=*(cStr+3);//将总共需要发送的字符数写入

    //received some data from tcp connection
   struct espconn *pespconn = arg;
   //os_strlen
   if(os_strstr(pusrdata,"GET"))
   {
	   os_strcpy(SendStr,res200_html);
	   os_strcat(SendStr,before_ssid_html);
	   os_strcat(SendStr,ssid_send);
	   os_strcat(SendStr,before_end_html);
	   espconn_sent(pespconn, SendStr, os_strlen(SendStr));
	   os_printf("true tcp recv : %s \r\n", pusrdata);
	   os_printf("tcp send: %s \r\n", SendStr);
   }
   else if(pBuf=strstr(pusrdata,"ssid="))
   {
	   os_printf("%s\r\n",pBuf);
	   while ( ( pStr = strtok ( pBuf, "=" ) ) != NULL )
	  		{
	  			value_temp[ i ++ ] = pStr;
	  			pBuf = NULL;
	  			if(i>5)break;
	  		}
	  os_strcpy(conn_ssid , apssid[ssidloop-(*(value_temp[1])-0x30)]);

	  pBuf_psw=value_temp[2];
	       while((*(pBuf_psw)!='-')&&(*(pBuf_psw)!='&')){pBuf_psw++;}
	       if((*(pBuf_psw)=='-'))
	       {
	    	   os_printf("1 - \r\n");
	    	   //pBuf_psw--;
	    	   strcpy(temp_setssid,pBuf_psw+1);
	    	   pBuf_myssid=temp_setssid;

	    	   while((*(pBuf_myssid)!='-')&&(*(pBuf_myssid)!='&')){pBuf_myssid++;}
	    	   if((*(pBuf_myssid)=='-'))
	    	   {
	    		   os_printf("2 - \r\n");
	    		   //pBuf_myssid--;
	    		   strcpy(temp_setpsw,pBuf_myssid+1);
	    		   pBuf_mypsw=temp_setpsw;
	    		   while((*(pBuf_mypsw)!='-')&&(*(pBuf_mypsw)!='&')){pBuf_mypsw++;}
	    		   *(pBuf_mypsw) =0;
	    		   os_strcpy(VA_param.param_my_psw,temp_setpsw);
	    		   os_printf("get psw:%s \r\n",VA_param.param_my_psw);
	    	   }
	    	   *(pBuf_myssid)=0;

	    	   os_strcpy(VA_param.param_my_ssid,temp_setssid);
	    	   //测试接收汉字的处理
	    	  /* os_strcpy(GB2312_test,"测试");
	    	   testbuf=GB2312_test;

	    	   os_printf("testbuf:%x ",GB2312_test[0]);
	    	   os_printf("%02x ",GB2312_test[1]);
	    	   os_printf("%02x ",GB2312_test[2]);
	    	   os_printf("%02x ",GB2312_test[3]);
	    	   os_printf("%02x ",GB2312_test[4]);
	    	   os_printf("%02x ",GB2312_test[5]);
	    	   os_printf("%02x ",GB2312_test[6]);
	    	   os_printf("%02x ",GB2312_test[7]);
	    	   os_printf("%02x \r\n",GB2312_test[8]);

	    	   os_strcpy(VA_param.param_my_ssid,GB2312_test);
	    	   os_printf("get ssid:%s \r\n",VA_param.param_my_ssid);*/

	    	   esp_VA_save_param();//save the new ssid/psw
	    	   os_printf("saved \r\n");
	       }

	       *(pBuf_psw)=0;//set the end \0
	       templen=strlen(value_temp[2]);
	       os_strcpy(conn_psw,value_temp[2]);//get password




	       VA_param.param_interval= *(value_temp[3]);//interval
	       os_printf("interval=%d \r\n",VA_param.param_interval);
	       switch(VA_param.param_interval){
	       	case 0x31: 	interval_timer_cnt=(1*60-6)*1000000;break;//1min
	       	case 0x32: 	interval_timer_cnt=(5*60-6)*1000000;break;//5min
	       	case 0x33: 	interval_timer_cnt=(10*60-6)*1000000;break;//10min
	       	case 0x34: 	interval_timer_cnt=(30*60-6)*1000000;break;//30min
	       	case 0x35: 	interval_timer_cnt=(60*60-6)*100000;break;//60min  over flow
	       	default:	interval_timer_cnt=(5*60-6)*1000000;break;
	       	}

	       strcpy(VA_param.param_ap_ssid,conn_ssid);
	       strcpy(VA_param.param_ap_psw,conn_psw);

	       stationConf.bssid_set = 0;
	       os_memcpy(&stationConf.ssid, conn_ssid, 32);
	       os_memcpy(&stationConf.password, conn_psw, 64);
	       os_printf("disconnect?: %d! \r\n",wifi_station_disconnect());

	       os_printf("Try to connect to %s! \r\n",stationConf.ssid);
	       os_printf("psw %s! \r\n",stationConf.password);
	       work_state=work_state_got_set;

	       wifi_station_set_config(&stationConf);//config the new connect
	       wifi_station_connect();//connect to new AP
	       os_timer_disarm(&check_ip_timer);
	       //在配置模式下收到配置数据后再启动连接查询定时器中断
	       os_timer_setfn(&check_ip_timer, (os_timer_func_t *)user_esp_platform_check_ip, NULL);
	       os_timer_arm(&check_ip_timer, 400, 0);
   }
   else
   {
	   os_printf("false tcp recv : %s \r\n", pusrdata);
   }
   os_printf("%s\r\n", arg);
   //espconn_sent(pespconn, pusrdata, length);
}

/******************************************************************************
 * FunctionName : tcp_server_discon_cb
 * Description  : disconnect callback.
 * Parameters   : arg -- Additional argument to pass to the callback function
 * Returns      : none
*******************************************************************************/
LOCAL void ICACHE_FLASH_ATTR
tcp_server_discon_cb(void *arg)
{
   //tcp disconnect successfully
    os_printf("tcp disconnect succeed !!! \r\n");
}

/******************************************************************************
 * FunctionName : tcp_server_recon_cb
 * Description  : reconnect callback, error occured in TCP connection.
 * Parameters   : arg -- Additional argument to pass to the callback function
 * Returns      : none
*******************************************************************************/
LOCAL void ICACHE_FLASH_ATTR
tcp_server_recon_cb(void *arg, sint8 err)
{
   //error occured , tcp connection broke.
    os_printf("reconnect callback, error code %d !!! \r\n",err);
}

LOCAL void tcp_server_mutli_sent(void)
{
   struct espconn *pesp_conn = &esp_conn;

   remot_info *premot = NULL;
   uint8 count = 0;
   sint8 value = ESPCONN_OK;
   if (espconn_get_connection_info(pesp_conn,&premot,0) == ESPCONN_OK){
      char *pbuf = "tcp_server_mutli_sent\n";
      for (count = 0; count < pesp_conn->link_cnt; count ++){
         pesp_conn->proto.tcp->remote_port = premot[count].remote_port;
         pesp_conn->proto.tcp->remote_ip[0] = premot->remote_ip[0];
         pesp_conn->proto.tcp->remote_ip[1] = premot->remote_ip[1];
         pesp_conn->proto.tcp->remote_ip[2] = premot->remote_ip[2];
         pesp_conn->proto.tcp->remote_ip[3] = premot->remote_ip[3];
      //   os_memcpy(pesp_conn->proto.tcp->remote_ip, premot->remote_ip);
         //espconn_sent(pesp_conn, pbuf, os_strlen(pbuf));
      }
   }
}

/******************************************************************************
 * FunctionName : tcp_server_listen
 * Description  : TCP server listened a connection successfully
 * Parameters   : arg -- Additional argument to pass to the callback function
 * Returns      : none
*******************************************************************************/
LOCAL void ICACHE_FLASH_ATTR
tcp_server_listen(void *arg)
{
    struct espconn *pesp_conn = arg;
    os_printf("tcp_server_listen !!! \r\n");

    espconn_regist_recvcb(pesp_conn, tcp_server_recv_cb);
    espconn_regist_reconcb(pesp_conn, tcp_server_recon_cb);
    espconn_regist_disconcb(pesp_conn, tcp_server_discon_cb);

    espconn_regist_sentcb(pesp_conn, tcp_server_sent_cb);
   tcp_server_mutli_sent();
}

/******************************************************************************
 * FunctionName : user_tcpserver_init
 * Description  : parameter initialize as a TCP server
 * Parameters   : port -- server port
 * Returns      : none
*******************************************************************************/
void ICACHE_FLASH_ATTR
user_tcpserver_init(uint32 port)
{
    esp_conn.type = ESPCONN_TCP;
    esp_conn.state = ESPCONN_NONE;
    esp_conn.proto.tcp = &esptcp;
    esp_conn.proto.tcp->local_port = port;
    espconn_regist_connectcb(&esp_conn, tcp_server_listen);

    sint8 ret = espconn_accept(&esp_conn);
    espconn_regist_time(&esp_conn,120,0);//timeout interval.
    if(ret==0)
    {
    	work_state=work_state_set_ser;
    	os_printf("espconn_accept [%d] !!! \r\n", ret);
    }
    else
    {
    	os_printf("espconn_accept [%d] !!! \r\n", ret);
    }
}

/******************************************************************************
 * FunctionName : user_esp_platform_check_ip
 * Description  : check whether get ip addr or not
 * Parameters   : none
 * Returns      : none
*******************************************************************************/
void ICACHE_FLASH_ATTR
user_esp_platform_check_ip(void)
{
    struct ip_info ipconfig;

   //disarm timer first
    os_timer_disarm(&check_ip_timer);

   //get ip info of ESP8266 station
    wifi_get_ip_info(STATION_IF, &ipconfig);

    if (wifi_station_get_connect_status() == STATION_GOT_IP && ipconfig.ip.addr != 0) {

    	os_printf("got ip !!! \r\n");
    	config_state=0;
    	os_timer_disarm(&led_flash_timer);//停止定时器
    	gpio_output_set( BIT5, 0, BIT5, 0);//GPIO5 --1 熄灭led

    	espconn_delete(&esp_conn);
    	if ( work_state==work_state_noip ) {
    		os_timer_disarm(&search_timer);
    		os_printf("disarm search_timer !!! \r\n");
    		work_state=work_state_conn_ap;
    		wifi_set_opmode(STATION_MODE);
    		user_tcp_connect();
    		//user_tcpserver_init(SERVER_LOCAL_PORT);

    	} else if (work_state==work_state_got_set) {
    		work_state=work_state_conn_ap;
    		esp_VA_save_param();//save the connected ap
    		os_printf("manual set connect !!! \r\n");
    		os_printf("AP saved!!! \r\n");
    		wifi_set_opmode(STATION_MODE);
    		user_tcp_connect();
    	}else if(work_state==work_state_set_ser){
    		os_printf("the saved ap connect timeout ,the server is set but still get ip auto !!! \r\n");
    		work_state=work_state_conn_ap;
    		wifi_set_opmode(STATION_MODE);
    		user_tcp_connect();
    	}

    } else {

        if ((wifi_station_get_connect_status() == STATION_WRONG_PASSWORD ||
                wifi_station_get_connect_status() == STATION_NO_AP_FOUND ||
                wifi_station_get_connect_status() == STATION_CONNECT_FAIL)) {

         os_printf("connect fail !!! \r\n");

        } else {

           //re-arm timer to check ip
            os_timer_setfn(&check_ip_timer, (os_timer_func_t *)user_esp_platform_check_ip, NULL);
            os_timer_arm(&check_ip_timer, 400, 0);
            os_printf("connecting:%d \r\n",wifi_station_get_connect_status());
        }
    }
}

/******************************************************************************
 * FunctionName : user_set_station_config
 * Description  : set the router info which ESP8266 station will connect to
 * Parameters   : none
 * Returns      : none
*******************************************************************************/
void ICACHE_FLASH_ATTR
user_set_station_config(void)
{
   // Wifi configuration
   //char ssid[32] = "VA_office";
   //char password[64] = "69523223";//"32232596";
   struct station_config stationConf;

   //need not mac address
   stationConf.bssid_set = 0;

   //Set ap settings
   os_memcpy(&stationConf.ssid, VA_param.param_ap_ssid, 32);
   os_memcpy(&stationConf.password, VA_param.param_ap_psw, 64);
   wifi_station_set_config(&stationConf);
   //os_printf("Try to connect to RD! \r\n");
   //set a timer to check whether got ip from router succeed or not.
   os_timer_disarm(&check_ip_timer);
   os_timer_setfn(&check_ip_timer, (os_timer_func_t *)user_esp_platform_check_ip, NULL);
   os_timer_arm(&check_ip_timer, 400, 0);

}

//these below  copy from forum
/******************************************************************************
 * FunctionName : scan_done
 * Description  : scan done callback
 * Parameters   :  arg: contain the aps information;
                          status: scan over status
 * Returns      : none
*******************************************************************************/
void ICACHE_FLASH_ATTR
scan_done(void *arg, STATUS status)
{
  uint8 ssid[33];
  char temp[128];
  char str_len=0;
  char ssid_NO=0;
  char cStr[256];
  char *pBuf,mactemp[20],i;

  if (status == OK)
  {
    struct bss_info *bss_link = (struct bss_info *)arg;
    bss_link = bss_link->next.stqe_next;//ignore the first one , it's invalid.

    	ssidloop=0;

    while (bss_link != NULL)
    {
      os_memset(ssid, 0, 33);
      if (os_strlen(bss_link->ssid) <= 32)
      {
        os_memcpy(ssid, bss_link->ssid, os_strlen(bss_link->ssid));
      }
      else
      {
        os_memcpy(ssid, bss_link->ssid, 32);
      }
      os_memcpy( apssid[ssidloop++],ssid,os_strlen(ssid));
      //myssid[ssidloop++]=ssid;

      os_printf("(%d,\"%s\",%d,\""MACSTR"\",%d)\r\n",
                 bss_link->authmode, ssid, bss_link->rssi,
                 MAC2STR(bss_link->bssid),bss_link->channel);
      bss_link = bss_link->next.stqe_next;
    }
  }
  else
  {
     os_printf("scan fail !!!\r\n");
  }

  pBuf=strstr(before_ssid_html,"0123456");//replace the default SN 0123456789->00xxxxxxxx
  for(i=0;i<10;i++)
  {
	*(pBuf+i)=VA_param.param_SN[i];
  }

  wifi_get_macaddr(STATION_IF,mymacaddr);
  //os_printf("mymacaddr:%s !!!\r\n",mymacaddr);

  os_printf("abcdef_%02x%02x%02x%02x%02x%02x\r\n", mymacaddr[0],mymacaddr[1],\
		  	  	  	  	  mymacaddr[2],mymacaddr[3], mymacaddr[4], mymacaddr[5]);

  pBuf=strstr(before_ssid_html,"A1:B2");

  os_sprintf(mactemp, "%02x:%02x:%02x:%02x:%02x:%02x", mymacaddr[0],mymacaddr[1],\
		  mymacaddr[2],mymacaddr[3], mymacaddr[4], mymacaddr[5]);
  for(i=0;i<17;i++)
  {
	  *(pBuf+i)=mactemp[i];

  }

  //判断是上电还是外部复位
  struct rst_info* user_rst_info;

  user_rst_info=system_get_rst_info();

      	os_printf("restart1:%d \r\n",user_rst_info->reason);
      	os_printf("restart2:%d \r\n",system_get_rst_info()->reason);
      	switch(user_rst_info->reason)
      	{
      	/*enum rst_reason {
      		REASON_DEFAULT_RST		= 0,
      		REASON_WDT_RST			= 1,
      		REASON_EXCEPTION_RST	= 2,
      		REASON_SOFT_WDT_RST   	= 3,
      		REASON_SOFT_RESTART 	= 4,
      		REASON_DEEP_SLEEP_AWAKE	= 5,
      		REASON_EXT_SYS_RST      = 6
      	};*/
      	case 0:	break;
      	case 1:	break;
      	case 2:	break;
      	case 3:	break;
      	case 4:	break;
      	case 5:	break;

      	case 6:	RTC_memory_read();
      				break;//external restart for config
      	default:break;

      	}


  if(config_state==1)//if config key is pressed
  {
	  os_timer_arm(&led_flash_timer,1000,1);
	 os_printf("config key is pressed,prepare for manual set!!!\r\n");
  }
  else if(config_state==0)
  {
	  os_timer_disarm(&led_flash_timer);//停止定时器
	  gpio_output_set( BIT5, 0, BIT5, 0);//GPIO5 --1 熄灭led
	  user_set_station_config();//set the target AP ssid psw
  }
  user_set_softap_config();//set 8266 ssid psw


  ssid_send[0]='\0';
  ssid_NO=0;
  while(ssidloop-ssid_NO>0)
  {
	ssid_NO++;
	if(ssid_NO>9){ssid_length++;}
	os_sprintf ( cStr, "<option value=\"%d\" class=\"column1\">%s</option>\r\n",ssid_NO,apssid[ssidloop-ssid_NO]  );
	//ssidloop--;
	os_printf("%s\r\n",cStr);
	ssid_length+=os_strlen(cStr);
	os_strcat(ssid_send,cStr);
	//ssid_send
  }

}

/******************************************************************************
 * FunctionName : user_scan
 * Description  : wifi scan, only can be called after system init done.
 * Parameters   :  none
 * Returns      : none
*******************************************************************************/
void ICACHE_FLASH_ATTR
user_scan(void)
{
   if(wifi_get_opmode() == SOFTAP_MODE)
   {
     os_printf("ap mode can't scan !!!\r\n");
     return;
   }
   wifi_station_scan(NULL,scan_done);

}

void ICACHE_FLASH_ATTR
smartconfig_done(sc_status status, void *pdata)
{
    switch(status) {
        case SC_STATUS_WAIT:
            os_printf("SC_STATUS_WAIT\n");
            break;
        case SC_STATUS_FIND_CHANNEL:
            os_printf("SC_STATUS_FIND_CHANNEL\n");
            break;
        case SC_STATUS_GETTING_SSID_PSWD:
            os_printf("SC_STATUS_GETTING_SSID_PSWD\n");
			sc_type *type = pdata;
            if (*type == SC_TYPE_ESPTOUCH) {
                os_printf("SC_TYPE:SC_TYPE_ESPTOUCH\n");
            } else {
                os_printf("SC_TYPE:SC_TYPE_AIRKISS\n");
            }
            break;
        case SC_STATUS_LINK:
            os_printf("SC_STATUS_LINK\n");
            struct station_config *sta_conf = pdata;

	        wifi_station_set_config(sta_conf);
	        wifi_station_disconnect();
	        wifi_station_connect();
            break;
        case SC_STATUS_LINK_OVER:
            os_printf("SC_STATUS_LINK_OVER\n");
            if (pdata != NULL) {
                uint8 phone_ip[4] = {0};

                os_memcpy(phone_ip, (uint8*)pdata, 4);
                os_printf("Phone ip: %d.%d.%d.%d\n",phone_ip[0],phone_ip[1],phone_ip[2],phone_ip[3]);

                os_timer_disarm(&rtc_test_t);
				os_timer_setfn(&rtc_test_t,test_timer_cb,NULL);
				os_timer_arm(&rtc_test_t,5000,1);
				os_printf("\r\nEnable timer!\r\n");
            }
            smartconfig_stop();
            //enable sleep timer


            break;
    }

}

/******************************************************************************
 * FunctionName : user_set_softap_config
 * Description  : set SSID and password of ESP8266 softAP
 * Parameters   : none
 * Returns      : none
*******************************************************************************/
void ICACHE_FLASH_ATTR
user_set_softap_config(void)
{
   struct softap_config config;

   wifi_softap_get_config(&config); // Get config first.

   //os_printf("VA_param.param_my_ssid:%s \r\n",VA_param.param_my_ssid);
   //os_printf("VA_param.param_my_psw:%s \r\n",VA_param.param_my_psw);

   os_memset(config.ssid, 0, 32);
   os_memset(config.password, 0, 64);
   os_memcpy(config.ssid,VA_param.param_my_ssid, 64);
   os_memcpy(config.password, VA_param.param_my_psw, 64);
   config.authmode = AUTH_WPA_WPA2_PSK;
   config.ssid_len = 0;// or its actual length
   config.max_connection = 4; // how many stations can connect to ESP8266 softAP at most.

   wifi_softap_set_config(&config);// Set ESP8266 softap config .

}

/******************************************************************************
 * FunctionName : key_init
 * Description  : init keys
 * Parameters   : key_param *keys - keys parameter, which inited by key_init_single
 * Returns      : none
*******************************************************************************/
void ICACHE_FLASH_ATTR
pin_init(uint32 gpio_name,uint8 gpio_id,uint8 gpio_func)
{
	//struct key_param *single_key = (struct key_param *)os_zalloc(sizeof(struct key_param));

	   /* single_key->gpio_id = gpio_id;
	    single_key->key_level = 1;
	    single_key->long_press = long_press;
	    single_key->short_press = short_press;

	    ETS_GPIO_INTR_ATTACH(key_intr_handler,single_key);
	    ETS_GPIO_INTR_DISABLE();

	    key_init(gpio_name, gpio_id, gpio_func);

	    ETS_GPIO_INTR_ENABLE();*/


        PIN_FUNC_SELECT(gpio_name,gpio_func);
        PIN_PULLUP_EN(gpio_name);
        gpio_output_set(0, 0, 0, GPIO_ID_PIN(gpio_id));

        gpio_register_set(GPIO_PIN_ADDR(gpio_id), GPIO_PIN_INT_TYPE_SET(GPIO_PIN_INTR_DISABLE)
                          | GPIO_PIN_PAD_DRIVER_SET(GPIO_PAD_DRIVER_DISABLE)
                          | GPIO_PIN_SOURCE_SET(GPIO_AS_PIN_SOURCE));

        //clear interrupt status
        GPIO_REG_WRITE(GPIO_STATUS_W1TC_ADDRESS, BIT(gpio_id));

        //enable interrupt
        //gpio_pin_intr_state_set(GPIO_ID_PIN(gpio_id), GPIO_PIN_INTR_NEGEDGE);
}

void ICACHE_FLASH_ATTR
key_init(void)
{
    pin_init(PERIPHS_IO_MUX_GPIO4_U,4,0);
    pin_init(PERIPHS_IO_MUX_GPIO5_U,5,0);
}



INITFLAG_MEM init_data ;
void ICACHE_FLASH_ATTR
RTC_memory_read()
{
	 system_rtc_mem_read( INITFLAG_MEM_ADDR, &init_data, sizeof(INITFLAG_MEM) );

	 if(init_data.init_flg!=NOT_POWER_ON)//不等于 ，表示上电启动
	 {

		os_printf("power on! \r\n");
		init_data.init_flg=NOT_POWER_ON;
		system_rtc_mem_write(INITFLAG_MEM_ADDR, &init_data, sizeof(INITFLAG_MEM));
		os_printf("powered,set the (NOT_POWER_ON)! \r\n");
	 }
	 else
	 {
		 config_state=1;
		 os_printf("Ext Rst! \r\n");
		 os_printf("RTC_memory INIT,config_state=%d \r\n",config_state);
		 os_printf("NOT_POWER_ON=%x \r\n",NOT_POWER_ON);
	 }



}

void user_rf_pre_init(void)
{

}

void user_init(void)
{
	uint16 gpio_status;


	uart_init(115200, 115200);
	uart_rx_intr_enable(UART0);

    os_printf("SDK version:%s\n", system_get_sdk_version());
    work_state=work_state_noip;

    esp_VA_load_param();//加载参数（未做保护，待加入）

    key_init();


    i2c_master_gpio_init();

    /*gpio_status = GPIO_REG_READ(GPIO_IN_ADDRESS);
    os_printf("gpio_status:%08x! \r\n",gpio_status);

    if(gpio_status & BIT(4))//default pullup 1
    {
    	config_state=0;
    }
    else
    {
    	os_printf("config key pressed!! \r\n");
    	config_state=1;
    }*/
    //按键修改为在运行时的任意时刻按下，即可恢复运行并进入配置状态。config_state=1;

    os_printf("config_state:%d! \r\n",config_state);

	//running timer
    	/*os_timer_disarm(&test_timer);
		os_timer_setfn(&test_timer,test_timer_cb,NULL);
		os_timer_arm(&test_timer,3000,1);*/


    os_timer_disarm(&led_flash_timer);//led flash timer
    os_timer_setfn(&led_flash_timer,led_flash_timer_cb,NULL);
    //os_timer_arm(&led_flash_timer,1000,1);

    os_timer_disarm(&search_timer);
    os_timer_setfn(&search_timer,search_timer_cb,NULL);
    os_timer_arm(&search_timer,2000,1);//设置一个较大的定时值(9000)可使在自动连接成功前不显示出AP(web服务器不建立)

    //wifi_set_opmode(STATION_MODE);
    wifi_set_opmode(STATIONAP_MODE);

    // wifi scan has to after system init done.
     //user_set_station_config();
     system_init_done_cb(user_scan);

    //smartconfig_start(smartconfig_done);
    //sleep_type
}





